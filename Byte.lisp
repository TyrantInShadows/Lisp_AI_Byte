(defstruct gameState
            naPotezu 
            prviIgra
            tabla
            velicinaTable
            popunjenaPolja
            rezultatIgre
            krajIgre 
 )

(defun test (l)
  (car (cdr (car (cdr (car l)))) )
)
(defun PocetneOpcije ()
    (setf state
    (make-gameState :naPotezu 'X
                    :rezultatIgre '(0 0))
    )
    (princ "Unesite 8 ili 10 u zavisnosti od velicine tabele na kojoj zelite da igrate: ")
    (setf (gameState-velicinaTable state) (read))
    ;;(GenerisiTabelu (gameState-velicinaTable state) 0)

    (setf (gameState-tabla state)
    '(((B NIL) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL))
    ((W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL))
    ((B NIL) (W NIL) (B (X)) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL))
    ((W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL))
    ((B NIL) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL))
    ((W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL) (B NIL))
    ((B NIL) (W NIL) (B (X)) (W NIL) (B NIL) (W NIL) (B NIL) (W NIL))
    ((W NIL) (B NIL) (W NIL) (B (O)) (W NIL) (B NIL) (W NIL) (B NIL))))
    (princ "Unesite P ili K u zavisnosti da li zelite igrac ili racunar da igra prvi, respektivno: ")
    (setf (gameState-prviIgra state) (read))
    ;;(princ (OdrediNajblizi 2 2 (gameState-velicinaTable state) (gameState-tabla state) 0))
    (LegitimnoPomeranjeNaPrazno 2 2 2 4)

    ;; (setf (gameState-tabla state) (PronadjiElement+ 1 2 (gameState-tabla state) 0 t "dodaj" 'X))
    ;; (setf (gameState-tabla state) (PronadjiElement+ 1 2 (gameState-tabla state) 0 t "dodaj" 'O))
    ;; (setf (gameState-tabla state) (PronadjiElement+ 1 1 (gameState-tabla state) 0 t "izbaci" 'X))
)
;;za generisanje tabele 
(defun GenerisiTabelu(velicina i)
    (cond
        ((equalp velicina i)'())
        (t(setf (gameState-tabla state) (cons (GenerisiRed i 0) (GenerisiTabelu velicina (1+ i)))))
    )
)
;;za generisanje reda u matrici (i-Br_reda,j-Br_kolone)
(defun GenerisiRed(i j)
    (cond
        ((equalp j 8)'())
        ((equalp 0 (mod (+ i j) 2)) (cons (list 'B (OdrediDisk i)) (GenerisiRed i (1+ j))))
        (t (cons (list 'W '()) (GenerisiRed i (1+ j))))
    )
)
;;odredjuje koja vrsta diska ce biti na toj poziciji(i-Br_reda)
(defun OdrediDisk (i)
    (cond
        ((OR (equalp i 0) (equal i 7))'())
        ((equalp 0 (mod i 2))(list 'X))
        (t (list 'O))
    )
)
;;Vraca specificno polje (i-BR_reda,j-Br_kolone,l-tabela )
(defun PronadjiElement (i j l)
    (PronadjiElement1 j (PronadjiElement1  i l 0) 0)
)
;;Sluzi za dodavanje i izbacivanje elementa na/sa polja(i,j-koordinate polja,l-tabela,bool-kad je true onda trazimo red false kolonu,operacija da li izbacujemo ili ubacujemo elemnt, el-koj element ubacujemo/visina sa koje izbacujemo)
(defun PronadjiElement+ (i j l index bool operacija el)
    (cond 
        ((null l)'())
        ((equalp i index)(if (equalp bool t)
                        (cons (PronadjiElement+ j i (car l) 0 '() operacija el) (cdr l))
                        (if (equalp operacija "dodaj") 
                            (cons (cons (car (car l)) (list (DodajElement (car (cdr (car l))) el))) (cdr l))
                            (cons (cons (car (car l))(list (IzbaciElement (car (cdr (car l))) (length (car (cdr (car l)))) 0 el))) (cdr l))  
                        )))
        (t(cons (car l) (PronadjiElement+ i j (cdr l) (1+ index) bool operacija el)))
    )
)
;;Pronalazi element liste(i-mesto u listi, l-lista,index-brojac)
(defun PronadjiElement1 (i l index)
    (cond 
        ((null l)'())
        ((equalp i index)(car l))
        (t(PronadjiElement1 i (cdr l) (1+ index)))
    )
)
;;Odredjuje visinu steka(l-stek)
(defun VisinaSteka (l)
    (length (car (cdr l)))
)
;;pomocna funkcija za Pronadjielement+ poziva se da bi dodao odgovarajuci el
(defun DodajElement (l el)
    (cond
        ((null l)(list el))
        (t(cons (car l) (DodajElement (cdr l) el)))
    )
)
;;pomocna funkcija za Pronadjielement+ poziva se da bi izbacio odredjene elemente visine el sa steka(l-lista, duzina-duzina te liste, index-brojac, visina-visina sa koje izbacujemo)
(defun IzbaciElement (l duzina index visina)
    (cond
        ((null l)'())
        ((equalp (- 1 (- duzina visina)) index)'())
        (t(cons (car l) (IzbaciElement (cdr l) duzina (1+ index))))
    )
)
;;Fala bogu stigo smo do kraj, konacna funkcija za proveru da lli je pomeranje na prazno polje adekvatno
(defun LegitimnoPomeranjeNaPrazno (iDiska jDiska iPomeraj jPomeraj)
    (setf lista (OdrediNajblizi iDiska jDiska (gameState-velicinaTable state) (gameState-tabla state) 0))
    (cond
        ((AND (< (- iPomeraj iDiska) 0)(< (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 1 lista))
        ((AND (> (- iPomeraj iDiska) 0)(> (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 2 lista))
        ((AND (< (- iPomeraj iDiska) 0)(> (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 3 lista))
        ((AND (> (- iPomeraj iDiska) 0)(< (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 4 lista))
    )
)
;;pomocna funkcija za LegitimnoPomeranjeNaPrazno proverava da li je potez validan (iPomeraj,jPomeraj-kordinate gde pomeramo, kon-kondition tj koj trougao gledamo, l lista sa kojom radimo)
(defun ProveriKavadrant (iPomeraj jPomeraj kon l)
    (cond
        ((null l)'())
        ((equalp kon 1) (if (>= (+  iPomeraj jPomeraj) (+ (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
        ((equalp kon 2) (if (<= (+ iPomeraj jPomeraj) (+ (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
        ((equalp kon 3) (if (>= (- iPomeraj jPomeraj) (- (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
        ((equalp kon 4) (if (<= (- iPomeraj jPomeraj) (- (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
    )
)

;;Vraca samo one na najmanjem nivou 
(defun OdrediNajblizi (iDiska jDiska maxi l index)
    (setf (gameState-popunjenaPolja state) (append (gameState-popunjenaPolja state) (ParLista (- iDiska index) (+ iDiska index) l maxi iDiska jDiska)))
    (setf lista (OdrediNajmanjiNivo index  (gameState-popunjenaPolja state)))
    (cond
        ((null lista) (OdrediNajblizi iDiska jDiska maxi l (1+ index)))
        (t lista)
    )
)
;;Obradjuej red i rezultat joj je lista gde svaki element kao svoj prvi element ima br poteza do njega i drugi element lista koordinata
;;(i,j-koordinate elemnta koji se u trenutku ispituje, l-red sa kojim radimo, iDiska,jDiska-koordinate polja sa kog se prebacuje)
(defun ObradiListu (i j l iDiska jDiska)
    (cond
        ((null l)'())
        ((> (VisinaSteka (car l)) 0)(if (AND (equalp i iDiska) (equalp j jDiska))   
                                    (ObradiListu i (1+ j) (cdr l) iDiska jDiska)
                                    (if (> (abs (- i iDiska)) (abs (- j jDiska)))
                                        (cons (list (- i iDiska) (list i j)) (ObradiListu i (1+ j) (cdr l) iDiska jDiska))
                                        (cons (list (- j jDiska) (list i j))(ObradiListu i (1+ j) (cdr l) iDiska jDiska))
                                    )))
        (t(ObradiListu i (1+ j) (cdr l) iDiska jDiska))
    )
)
;;Vraca elemente sa najmanjeg nivoa, ako je najmanji nivo jednak indexu 
(defun OdrediNajmanjiNivo (index l)
    (cond
        ((null l)'())
        ((equalp (car (car l)) index)(cons (car l) (OdrediNajmanjiNivo index (cdr l))))
        (t(OdrediNajmanjiNivo index (cdr l)))
    )
)
;;Spaja rezultate dve liste nastale kao rez ObradiListu funkcije(i1-BR1_reda,i2-BR2_reda,l-tabla, maxi-maximalna velicina reda, iDiska,jDiska-koordinate polja sa kog se prebacuje)
(defun ParLista (i1 i2 l maxi iDiska jDiska)
    (case
    (equalp i1 i2) (ObradiListu i1 0 (PronadjiElement1 i1 l 0) iDiska jDiska)
    ((OR (< i1 0) (> i1 maxi))(ObradiListu i2 0 (PronadjiElement1 i2 l 0) iDiska jDiska))
    ((OR (< i2 0) (> i2 maxi))(ObradiListu i1 0 (PronadjiElement1 i1 l 0) iDiska jDiska))
    (t(append (ObradiListu i1 0 (PronadjiElement1 i1 l 0) iDiska jDiska) (ObradiListu i2 0 (PronadjiElement1 i2 l 0) iDiska jDiska)))
    )
)
;;Prebacivanje sa stacka na stack (s1 je prvi stack,a s2 drugi,n je nivo sa koga stack 1 prebacujemo na 2)
(defun StackOnStack (s1 s2 n)
    (if (< n (length s2))
        (if (FiguraPripadaIgracu s1 n 0)
            (if (<= (+ (length (VratiStackN s1 n 0)) (length s2)) 8 ) t 
            nil)
        nil)
    nil) 
)
;; vraca deo stacka od nivoa n (s-stack,n-nivo,i-iterator)
(defun VratiStackN (s n i)
    (cond
    ((equalp i n) s)
    (t (VratiStackN (cdr s) n (1+ i)))
    )
)
;;Da li figura na odredjenom nivou u stacku pripada igracu koji je trenutno na potezu (s-stack,n-nivo, i-iterator)
(defun FiguraPripadaIgracu (s n i)
    (cond 
        ((= n i)
            (if (equalp (car s) (gameState-naPotezu state)) t nil)
        )
        (t (FiguraPripadaIgracu (cdr s) n (1+ i)))
    )
)
(PocetneOpcije)
(setq stack1 '(X O X X O))
(setq stack2 '(X O X O))
