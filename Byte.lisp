(defstruct gameState
            naPotezu 
            prviIgra
            tabla
            velicinaTable
            popunjenaPolja
            rezultatIgre
            krajIgre 
 )

(defun test ()
  (setf (gameState-rezultatIgre state)(cons (car (gameState-rezultatIgre state))(list (1+ (car (cdr (gameState-rezultatIgre state)))))))
)
(defun PocetneOpcije ()
    (setf state
    (make-gameState :naPotezu 'X
                    :rezultatIgre '(0 0))
    )
    (princ "Unesite 8 ili 10 u zavisnosti od velicine tabele na kojoj zelite da igrate: ")
    (setf (gameState-velicinaTable state) (read))
    (GenerisiTabelu (gameState-velicinaTable state) 0)

    (setf (gameState-tabla state) (GenerisiTabelu (gameState-velicinaTable state)  0))
    (princ "Unesite P ili K u zavisnosti da li zelite igrac ili racunar da igra prvi, respektivno: ")
    (setf (gameState-prviIgra state) (read))
    (napotezu)
)
(defun napotezu ()
    (Display (gameState-tabla state) 9)
    (format t "Na potezu je ~a" (gameState-naPotezu state))
)
(defun Display (l nivo)
    (cond
    ((null l) NIL)
    ((equalp nivo 0) (format t "~%") (Display (cdr l) 9))
    (t (DisplayRow (car l) nivo) (Display l (- nivo 3)))
    )
)
(defun DisplayRow (row nivo)
    (cond 
        ((null row) (terpri))
        (t (DisplayField (car row) nivo) (DisplayRow (cdr row) nivo))
    )
)
(defun DisplayField (field nivo)
    
    (cond 
        ((equalp 'W (car field)) (format t "      "))
        ((null (car (cdr field))) (format t " - - - "))
        ((equalp 'B (car field)) (format t "~x" (DispalyFieldContent (car (cdr field)) (car (cdr field)) 0 (- nivo 3) nivo)))
    )
)
(defun DispalyFieldContent (lista l index nivo max)
    (cond
        ((= index max) '())
        ((> nivo (length lista)) '(- - -))
        ((null l) (append '(-) (DispalyFieldContent lista '() (1+ index) nivo max)))
        ((>= index nivo) (cons (car l) (DispalyFieldContent lista (cdr l) (1+ index) nivo max)))
        (t (DispalyFieldContent lista (cdr l) (1+ index) nivo max))
    )
)

(defun Pomeri (iDiska jDiska iPomeraj jPomeraj visina)
    (setf x (car (cdr (PronadjiElement iPomeraj jPomeraj (gameState-tabla state)))))
    (setf lista12 (ProveriIgraca iDiska jDiska visina))
    (princ lista12)
    (if (> (length lista12) 0)
        (if (LegitimnoPomeranje iDiska jDiska iPomeraj jPomeraj)
            (if (equalp (length x) 0)
                (if (equalp (LegitimnoPomeranjeNaPrazno iDiska jDiska iPomeraj jPomeraj) t)
                    (Pomeraj iDiska jDiska iPomeraj jPomeraj (- visina 1) lista12)
                    '())
                (if (equalp (length lista12) 1)
                    (Pomeraj iDiska jDiska iPomeraj jPomeraj (- visina 1) lista12)
                    (if (equalp t (StackOnStack (car (cdr (PronadjiElement iDiska jDiska (gameState-tabla state)))) x 0))
                        (Pomeraj iDiska jDiska iPomeraj jPomeraj (- visina 1) lista12)
                        '()
                    )
                ))
            '()
        )
        '()
    )
    (napotezu)
)

(defun ProveriPobedu (i j l)
    (setf lista (car (cdr (PronadjiElement i j (gameState-tabla state)))))
    (if (equalp lista (gameState-velicinaTable state))
        (if (equalp (PoslednjiDiskNaStack lista 0) 'X)
            (setf (gameState-rezultatIgre state)(cons (1+ (car (gameState-rezultatIgre state)))(cdr (gameState-rezultatIgre state))))
            (setf (gameState-rezultatIgre state)(cons (car (gameState-rezultatIgre state))(list (1+ (car (cdr (gameState-rezultatIgre state)))))))
        ))
    (if (equalp (gameState-velicinaTable state) 8)
        (let ((x 2)))
        (let ((x 3)))
    )
    (cond 
        ((equalp (car (gameState-rezultatIgre state)) x)(gameState-krajIgre state) 'X)
        ((equalp (car (cdr (gameState-rezultatIgre state))) x)(gameState-krajIgre state) 'O)
    )
    ;;(setf (gameState-tabla state)(PronadjiElement+ i j l 0 t "izbaci" 0))
)
(defun PoslednjiDiskNaStack (s i)
    (cond 
        ((= i (- (gameState-velicinaTable state) 1)) (car s))
        (t (PoslednjiDiskNaStack (cdr s) (1+ i)))
    )
)

(defun Pomeraj (iDiska jDiska iPomeraj jPomeraj visina lista)
    (setf (gameState-tabla state) (PronadjiElement+ iPomeraj jPomeraj (gameState-tabla state) 0 t "dodaj" lista))
    (setf (gameState-tabla state) (PronadjiElement+ iDiska jDiska (gameState-tabla state) 0 t "izbaci" visina))
    (if (equalp (gameState-naPotezu state) 'X)
        (setf (gameState-naPotezu state) 'O)
        (setf (gameState-naPotezu state) 'X)
    )
    (setf (gameState-popunjenaPolja state) '())
    (ProveriPobedu iPomeraj jPomeraj (gameState-tabla state))

)

(defun ProveriIgraca (iDiska jDiska visina)
     (setf lista (VratiDeoListe (- visina 1) (car (cdr (PronadjiElement iDiska jDiska (gameState-tabla state))))0))
     (if (equalp (gameState-naPotezu state) (car lista))
        lista
        '()
     )
)
(defun VratiDeoListe (i l index)
    (cond 
        ((null l)'())
        ((equalp i 0) l)
        ((equalp (- i 1) index)(cdr l))
        (t(VratiDeoListe i (cdr l) (1+ index)))
    )
)

(defun LegitimnoPomeranje (iPomeraj jPomeraj iDiska jDiska)
    (cond
        ((AND(equalp (- iPomeraj iDiska) -1)(equalp (- jPomeraj jDiska) -1)) t)
        ((AND(equalp (- iPomeraj iDiska) 1)(equalp (- jPomeraj jDiska) 1)) t)
        ((AND(equalp (- iPomeraj iDiska) -1)(equalp (- jPomeraj jDiska) 1)) t)
        ((AND(equalp (- iPomeraj iDiska) 1)(equalp (- jPomeraj jDiska) -1)) t)
        (t '())
    )
)
;;za generisanje tabele 
(defun GenerisiTabelu(velicina i)
    (cond
        ((equalp velicina i)'())
        (t(setf (gameState-tabla state) (cons (GenerisiRed i 0) (GenerisiTabelu velicina (1+ i)))))
    )
)
;;za generisanje reda u matrici (i-Br_reda,j-Br_kolone)
(defun GenerisiRed(i j)
    (cond
        ((equalp j (gameState-velicinaTable state))'())
        ((equalp 0 (mod (+ i j) 2)) (cons (list 'B (OdrediDisk i)) (GenerisiRed i (1+ j))))
        (t (cons (list 'W '()) (GenerisiRed i (1+ j))))
    )
)
;;odredjuje koja vrsta diska ce biti na toj poziciji(i-Br_reda)
(defun OdrediDisk (i)
    (cond
        ((OR (equalp i 0) (equal i (- (gameState-velicinaTable state) 1)))'())
        ((equalp 0 (mod i 2))(list 'X))
        (t (list 'O))
    )
)
;;Vraca specificno polje (i-BR_reda,j-Br_kolone,l-tabela )
(defun PronadjiElement (i j l)
    (PronadjiElement1 j (PronadjiElement1  i l 0) 0)
)
;;Sluzi za dodavanje i izbacivanje elementa na/sa polja(i,j-koordinate polja,l-tabela,bool-kad je true onda trazimo red false kolonu,operacija da li izbacujemo ili ubacujemo elemnt, el-koj element ubacujemo/visina sa koje izbacujemo)
(defun PronadjiElement+ (i j l index bool operacija el)
    (cond 
        ((null l)'())
        ((equalp i index)(if (equalp bool t)
                        (cons (PronadjiElement+ j i (car l) 0 '() operacija el) (cdr l))
                        (if (equalp operacija "dodaj") 
                            (cons (cons (car (car l)) (list (DodajElement (car (cdr (car l))) el))) (cdr l))
                            (cons (cons (car (car l))(list (IzbaciElement (car (cdr (car l))) (length (car (cdr (car l)))) 0 el))) (cdr l))  
                        )))
        (t(cons (car l) (PronadjiElement+ i j (cdr l) (1+ index) bool operacija el)))
    )
)
;;Pronalazi element liste(i-mesto u listi, l-lista,index-brojac)
(defun PronadjiElement1 (i l index)
    (cond 
        ((null l)'())
        ((equalp i index)(car l))
        (t(PronadjiElement1 i (cdr l) (1+ index)))
    )
)
;;Odredjuje visinu steka(l-stek)
(defun VisinaSteka (l)
    (length (car (cdr l)))
)
;;pomocna funkcija za Pronadjielement+ poziva se da bi dodao odgovarajuci el
(defun DodajElement (l el)
    (cond
        ((null l) el)
        (t(append (list (car l)) (DodajElement (cdr l) el)))
    )
)
;;pomocna funkcija za Pronadjielement+ poziva se da bi izbacio odredjene elemente visine el sa steka(l-lista, duzina-duzina te liste, index-brojac, visina-visina sa koje izbacujemo)
(defun IzbaciElement (l duzina index visina)
    (cond
        ((null l)'())
        ((equalp visina index)'())
        (t(cons (car l) (IzbaciElement (cdr l) duzina (1+ index) visina)))
    )
)
;;Fala bogu stigo smo do kraj, konacna funkcija za proveru da lli je pomeranje na prazno polje adekvatno
(defun LegitimnoPomeranjeNaPrazno (iDiska jDiska iPomeraj jPomeraj)
    (setf lista (OdrediNajblizi iDiska jDiska (gameState-velicinaTable state) (gameState-tabla state) 0))
    (cond
        ((AND (< (- iPomeraj iDiska) 0)(< (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 1 lista))
        ((AND (> (- iPomeraj iDiska) 0)(> (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 2 lista))
        ((AND (< (- iPomeraj iDiska) 0)(> (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 3 lista))
        ((AND (> (- iPomeraj iDiska) 0)(< (- jPomeraj jDiska) 0)) (ProveriKavadrant iPomeraj jPomeraj 4 lista))
    )
)
;;pomocna funkcija za LegitimnoPomeranjeNaPrazno proverava da li je potez validan (iPomeraj,jPomeraj-kordinate gde pomeramo, kon-kondition tj koj trougao gledamo, l lista sa kojom radimo)
(defun ProveriKavadrant (iPomeraj jPomeraj kon l)
    (cond
        ((null l)'())
        ((equalp kon 1) (if (>= (+  iPomeraj jPomeraj) (+ (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
        ((equalp kon 2) (if (<= (+ iPomeraj jPomeraj) (+ (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
        ((equalp kon 3) (if (>= (- iPomeraj jPomeraj) (- (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
        ((equalp kon 4) (if (<= (- iPomeraj jPomeraj) (- (car (car (cdr (car l)))) (car (cdr (car (cdr (car l)))) )))
                            t
                            (ProveriKavadrant iPomeraj jPomeraj kon (cdr l))
                        ))
    )
)

;;Vraca samo one na najmanjem nivou 
(defun OdrediNajblizi (iDiska jDiska maxi l index)
    (setf (gameState-popunjenaPolja state) (append (gameState-popunjenaPolja state) (ParLista (- iDiska index) (+ iDiska index) l maxi iDiska jDiska)))
    (setf lista (OdrediNajmanjiNivo index  (gameState-popunjenaPolja state)))
    (cond
        ((null lista) (OdrediNajblizi iDiska jDiska maxi l (1+ index)))
        (t lista)
    )
)
;;Obradjuej red i rezultat joj je lista gde svaki element kao svoj prvi element ima br poteza do njega i drugi element lista koordinata
;;(i,j-koordinate elemnta koji se u trenutku ispituje, l-red sa kojim radimo, iDiska,jDiska-koordinate polja sa kog se prebacuje)
(defun ObradiListu (i j l iDiska jDiska)
    (cond
        ((null l)'())
        ((> (VisinaSteka (car l)) 0)(if (AND (equalp i iDiska) (equalp j jDiska))   
                                    (ObradiListu i (1+ j) (cdr l) iDiska jDiska)
                                    (if (> (abs (- i iDiska)) (abs (- j jDiska)))
                                        (cons (list (abs (- i iDiska)) (list i j)) (ObradiListu i (1+ j) (cdr l) iDiska jDiska))
                                        (cons (list (abs (- j jDiska)) (list i j))(ObradiListu i (1+ j) (cdr l) iDiska jDiska))
                                    )))
        (t(ObradiListu i (1+ j) (cdr l) iDiska jDiska))
    )
)
;;Vraca elemente sa najmanjeg nivoa, ako je najmanji nivo jednak indexu 
(defun OdrediNajmanjiNivo (index l)
    (cond
        ((null l)'())
        ((equalp (car (car l)) index)(cons (car l) (OdrediNajmanjiNivo index (cdr l))))
        (t(OdrediNajmanjiNivo index (cdr l)))
    )
)
;;Spaja rezultate dve liste nastale kao rez ObradiListu funkcije(i1-BR1_reda,i2-BR2_reda,l-tabla, maxi-maximalna velicina reda, iDiska,jDiska-koordinate polja sa kog se prebacuje)
(defun ParLista (i1 i2 l maxi iDiska jDiska)
    (cond
    ((equalp i1 i2) (ObradiListu i1 0 (PronadjiElement1 i1 l 0) iDiska jDiska))
    ((OR (< i1 0) (> i1 maxi))(ObradiListu i2 0 (PronadjiElement1 i2 l 0) iDiska jDiska))
    ((OR (< i2 0) (> i2 maxi))(ObradiListu i1 0 (PronadjiElement1 i1 l 0) iDiska jDiska))
    (t(append (ObradiListu i1 0 (PronadjiElement1 i1 l 0) iDiska jDiska) (ObradiListu i2 0 (PronadjiElement1 i2 l 0) iDiska jDiska)))
    )
)
;;Prebacivanje sa stacka na stack (s1 je prvi stack,a s2 drugi,n je nivo sa koga stack 1 prebacujemo na 2)
(defun StackOnStack (s1 s2 n)
    (if (< n (length s2))
        (if (FiguraPripadaIgracu s1 n 0)
            (if (<= (+ (length (VratiStackN s1 n 0)) (length s2)) 8 ) t 
            nil)
        nil)
    nil) 
)
;; vraca deo stacka od nivoa n (s-stack,n-nivo,i-iterator)
(defun VratiStackN (s n i)
    (cond
    ((equalp i n) s)
    (t (VratiStackN (cdr s) n (1+ i)))
    )
)
;;Da li figura na odredjenom nivou u stacku pripada igracu koji je trenutno na potezu (s-stack,n-nivo, i-iterator)
(defun FiguraPripadaIgracu (s n i)
    (cond 
        ((= n i)
            (if (equalp (car s) (gameState-naPotezu state)) t nil)
        )
        (t (FiguraPripadaIgracu (cdr s) n (1+ i)))
    )
)

(PocetneOpcije)

